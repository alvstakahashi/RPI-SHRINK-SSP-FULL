lrレジスタの保存について.txt

void __attribute__((interrupt("IRQ"))) 
IRQ_handler(void)

00000064 <IRQ_handler>:
  64:	e24ee004 	sub	lr, lr, #4
  68:	e92d581f 	push	{r0, r1, r2, r3, r4, fp, ip, lr}
  6c:	e28db01c 	add	fp, sp, #28
略
  a4:	e24bd01c 	sub	sp, fp, #28
  a8:	e8fd981f 	ldm	sp!, {r0, r1, r2, r3, r4, fp, ip, pc}^

というコードが出力されるが、lrレジスタが保護されないのは問題が無いのか？

実際に当カーネルでは問題がでた。

Inline void enable_IRQ(void)
{
	__asm__(
			"mrs	r0, cpsr;"
			"bic r0, r0, #0x80;"
			"msr cpsr_c,r0;"
			:::"r0"
			);
}
この割り込み許可ルーチンは、実際には関数リターンのコードが出力され、最後2stepは以下の
ようになる
		msr cpsr_c,r0
		bx		lr
このbx lrの処理直前に割りこまれ、lxの値が変化していたため例外動作していた。
10usタイマにすると確実にそうなった。

本来、lrはCPUモード別に値を持っているため、割り込みルーチンで保護する必要は無い。
なので値は変わらないはずである。しかし実際に変化していた。
理由は単純で、RTOSが当該割りこまれたタスクが復帰するまでに、別のタスクが起動することで
SVCモードになる。そのためそこでlrレジスタは使われるからである。
なので、割り込みの出入り口でSVCモードのlrレジスタの保存とロードを追加した。

TOPPERSの実装例では、アセンブリ言語で記載
割込みに入った最初に、SVCモードに変えてからレジスタ保存、SVCモードで割り込みロジック
を実行させている。
一方当カーネルは、attribute interrupt "IRQ"を使いCで記載する方針なので、
割込みルーチンはIRQモードのまま使うが、SVCモードのlrのみ保存するものとした。


