lrレジスタの保存について.txt

void __attribute__((interrupt("IRQ"))) 
IRQ_handler(void)

00000064 <IRQ_handler>:
  64:	e24ee004 	sub	lr, lr, #4
  68:	e92d581f 	push	{r0, r1, r2, r3, r4, fp, ip, lr}
  6c:	e28db01c 	add	fp, sp, #28
略
  a4:	e24bd01c 	sub	sp, fp, #28
  a8:	e8fd981f 	ldm	sp!, {r0, r1, r2, r3, r4, fp, ip, pc}^

というコードが出力されるが、lrレジスタが保護されないのは問題が無いのか？

実際に当カーネルでは問題がでた。

Inline void enable_IRQ(void)
{
	__asm__(
			"mrs	r0, cpsr;"
			"bic r0, r0, #0x80;"
			"msr cpsr_c,r0;"
			:::"r0"
			);
}
この割り込み許可ルーチンは、実際には関数リターンのコードが出力され、最後2stepは以下の
ようになる
		msr cpsr_c,r0
		bx		lr
このbx lrの処理直前に割りこまれ、lxの値が変化していたため例外動作していた。
10usタイマにすると確実にそうなった。

本来、lrはCPUモード別に値を持っているため、割り込みルーチンで保護する必要は無い。
なので値は変わらないはずである。しかし実際に変化していた。
理由は単純で、RTOSが当該割りこまれたタスクが復帰するまでに、別のタスクが起動することで
SVCモードになる。そのためそこでlrレジスタは使われるからである。
なので、割り込みの出入り口でSVCモードのlrレジスタの保存とロードを追加した。

TOPPERSの実装例では、アセンブリ言語で記載
割込みに入った最初に、SVCモードに変えてからレジスタ保存、SVCモードで割り込みロジック
を実行させている。
一方当カーネルは、attribute interrupt "IRQ"を使いCで記載する方針なので、
割込みルーチンはIRQモードのまま使うが、SVCモードのlrのみ保存するものとした。

2017.8.21 追記
1.SVCモードに戻した理由
　現在、割り込みはdelayタスクのみタイマ割り込みのみ利用しているため
　多重割り込み禁止にしていたので問題にはならないが、IRQモードで多重割り込みを
　した場合にlrレジスタが消失すると考える。
　つまり、IRQモードで割り込みが発生するとLRがPCに上書きされてしまい、LRがなくなって
　しまう。SVCモードの場合は、IRQのLRが変化するがSVCのLRはそのままなのでセーブ可能になる。
　当カーネルもSVCモードで動作するものに戻した。

2.r5-r10レジスタ保存の追加
　calleeレジスタで、割り込みで利用していないので保存しなくていいという意見が多いが、
　RTOSの場合、少なくとも当カーネルの場合は保存が必要。
　理由：
　例えば、仮に割り込み処理中に一切R5-R10を利用していないということが明らかなら、
　保存する必要は無いと考える。
　しかし、割り込み処理がコンパイラの保護によって入口と出口で保護しているので保存できている
　と言うならそれは違うと考える。
　なぜなら、入口と出口の間に割りこんで動作することがRTOSの動作なのでコンパイラによる
　保証は保証にならない。
　また、コンパイラがR5-R10まで一切使わないコードしか出さないのならCPUリソースを有効利用
　しないダメコンパイラだと考える。
　当カーネルはタスクRUNから割り込み後、別の優先度の高いタスクに切り替わる場合、
　irq_handlerの入り口から入って、リターンするのは別の優先度の高いタスクが終了してからである。
　つまり、irq_handler内であらゆるレジスタが操作されることが想定されるからである。

2017.8.22 追記
r5-r10レジスタ保存について昨日2017.8.21には間違いがありました。
これ(calleeセーブレジスタ)の保存が必要な場合は、タスクスイッチする場合のみです。
タスクスイッチする場合にのみ保存すればよいことになります。
多重割り込みの場合は、コンパイラの意図した戻り方をするためcalleeレジスタは
保証されます。タスクスイッチの判定時のみcalleeレジスタの保存と復帰をkernel_handlerに
追加しました。　これによって、常に割込みのたびに全レジスタ保存というメモリ効率の
悪い部分の改善ができたと思います。

